# Техническая документация

## Архитектурный обзор

Проект разделён по слоям, чтобы обеспечить заменяемость и возможность вынесения частей в отдельные сервисы:

- **domain/** — чистые модели и бизнес-правила (`Session`, `Task`, `Participant`).
- **ports/** — интерфейсы (контракты) для внешних зависимостей: `JiraClient`, `SessionRepository`, `Notifier`.
- **adapters/** — реализации портов: `jira_http.py` (HTTP к Jira), `session_file.py` (файловое хранилище), `telegram_notifier.py` (отправка сообщений через Bot API).
- **usecases/** — сценарии использования: добавление задач из Jira, старт батча, голосование, завершение, показ результатов, обновление SP в Jira и др. Все используют только порты и домен.
- **transport/telegram/** — aiogram-слой: роутеры, middleware, handlers. Минимум логики, только маршаллинг в use cases.
- **providers.py** — простой DI-контейнер, собирает адаптеры и use cases, прокидывается в transport через middleware.

Такое разделение позволяет вынести, например, Jira-клиент или хранилище сессий в отдельный микросервис, не меняя остальной код — нужно лишь реализовать новый адаптер, соответствующий порту.

## Жизненный цикл запроса
1. Aiogram получает update и через `DIMiddleware` добавляет `container` в `data` контекста хендлеров.
2. Хендлер (например, команда `/join` или callback `vote:*`) валидирует входные данные и вызывает нужный use case из контейнера.
3. Use case работает с доменной моделью и вызывает порты (`SessionRepository`, `JiraClient`, `Notifier`).
4. Результат отправляется пользователю через `Notifier` (Telegram-адаптер).
5. В `finally` блока `main.py` вызывается `container.cleanup()` — закрытие HTTP-сессии Jira и `bot.session`.

## Взаимодействие с Jira
- HTTP-адаптер `JiraHttpClient` реализует порт `JiraClient`.
- Поддерживает поиск по JQL и фоллбэк по ключам задач (regex), обновление Story Points.
- Максимально устойчив к изменениям API: перебор версий `rest/api/{3|2}` и обработка редиректов/404/410.
- Таймауты управляются через `aiohttp.ClientTimeout` (по умолчанию 30s).

## Хранение состояния
- Адаптер `session_file.py` использует `SessionStore` с атомарной записью (tmp + rename, file lock).
- Формат совместим со старой версией: `app/models/__init__.py` реэкспортирует доменные модели для обратной совместимости.
- Переключение на другое хранилище — реализовать новый адаптер `SessionRepository` (например, Redis/Postgres) и подставить в `DIContainer`.

## Голосование и вычисления
- Политика подсчёта вынесена в `VotingPolicy` (max, mode, average). Сейчас Story Points пишутся в Jira как максимум из голосов.
- Логика батча: `StartBatchUseCase` ставит `current_batch_started_at`, `FinishBatchUseCase` переносит задачи в `history` и `last_batch`, сбрасывает очередь.
- Пропуски (`skip`) считаются участием для перехода к следующей задаче, но не учитываются при расчёте SP.

## Обработка ошибок и UX
- Все обращения к Telegram идут через адаптер `TelegramNotifier`; ошибки заглатываются, чтобы не рушить поток.
- При добавлении задач показывается «⏳ Ожидайте…» и удаляется после завершения.
- При обновлении SP всегда отправляется резюме (включая случаи, когда ничего не обновлено).

## Как запустить
- `make install` — установить зависимости.
- `make run` — запустить бота (использует `run.py`, передаёт `--no-poll` по флагу).
- Конфигурация — через `.env` (см. `env.example`).

## Как тестировать
- `make test` или `pytest` (требует установленного `pytest`).
- Интеграционные тесты используют новые use cases и обновлённые импорты.

## Дальнейшие шаги к микросервисам
- Вынести Jira-адаптер в отдельный сервис (FastAPI/GRPC), `JiraClient` станет HTTP-клиентом к нему.
- Заменить файловое хранилище на Redis/Postgres адаптер (`SessionRepository`).
- Добавить health-check endpoints и наблюдаемость (metrics, structured logs).
- Ввести очереди событий (например, Kafka/Rabbit) для отправки аудита/экспортов без блокировки бота.
