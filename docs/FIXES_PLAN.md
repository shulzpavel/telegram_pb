# План исправлений и доработок Planning Poker Bot

## Контекст: основы Planning Poker

**Классическая методология:**
1. **Подготовка** — команда, Product Owner, user stories
2. **Презентация** — PO читает задачу, уточняет критерии
3. **Индивидуальная оценка** — участники выбирают карточки **независимо и одновременно**
4. **Раскрытие и обсуждение** — показывают карточки, обсуждают расхождения
5. **Повторное голосование** — до достижения консенсуса

**Отличия текущей реализации:**
- Голосование **последовательное** (каждый нажимает, когда готов)
- **Максимальное значение** вместо обсуждения и консенсуса
- Кнопка **"Нужен пересмотр"** — аналог раунда обсуждения
- **"Пропуск"** — не участвовать в оценке

---

## Критичные проблемы (сломают работу)

### 1. Тесты падают — отсутствие await для async методов

**Проблема:** После миграции на async use cases и SessionRepository тесты вызывают их без `await`, получают coroutine вместо результата.

**Файлы:** `test_services.py`, `test_handlers_reset_queue.py`, `test_integration.py`, `test_integration_e2e.py`

**Решение:**
- Перевести тесты на `async def` и `await`
- Использовать `pytest.mark.asyncio` для асинхронных тестов
- Заменить `self.repo.save_session(session)` на `await self.repo.save_session(session)`
- Заменить `self.use_case.execute(...)` на `await self.use_case.execute(...)`

### 2. needs_review: current_task_index = -1 при одной задаче

**Проблема:** В `callbacks.py` (строки 396–409):
```python
if was_single_task:
    # ... finish batch
    return
if current_index >= len(session.tasks_queue):
    session.current_task_index = len(session.tasks_queue) - 1  # = -1 при пустой очереди!
```
При одной задаче `was_single_task=True`, мы выходим раньше — ок.  
Но при `pop` последней задачи из нескольких: `current_index` может стать `>= len` после сдвига. Корректнее явно обработать случай "осталась одна задача".

**Решение:** Явно проверять `len(session.tasks_queue) == 0` после `pop` и вызывать `_finish_batch`.

### 3. Дублирование сообщений при смене задачи

**Проблема:** В `_start_next_task` при неудачном `edit_message`:
- Выставляется `session.active_vote_message_id = None`
- Отправляется **новое** сообщение
- Старое сообщение с голосованием **не удаляется**

**Решение:** Перед отправкой нового сообщения удалять старое (`delete_message`) при `active_vote_message_id`.

---

## Логические ошибки и неясные переходы

### 4. Прямая манипуляция состоянием в handlers

**Проблема:** Handlers напрямую меняют `session.current_task_index`, `session.active_vote_message_id` вместо use case.

**Примеры:**
- `callbacks.py:441` — `session.current_task_index += 1` после `all_voters_voted`
- `callbacks.py:393-395` — `task = session.tasks_queue.pop(current_index)`, `session.tasks_queue.append(task)`

**Решение:**
- Добавить `AdvanceToNextTaskUseCase` — инкремент индекса, сохранение, возврат флага «батч завершён»
- Добавить `NeedsReviewUseCase` — перенос задачи в конец очереди
- Handlers только вызывают use cases и показывают UI

### 5. Разные модели: SessionState vs Session

**Проблема:**  
`session_store.py` использует `SessionState` (votes как отдельное поле), `app/domain` — `Session` с votes внутри `Task`. Конвертация в `FileSessionRepository` может давать рассинхрон.

**Решение:**
- Привести `SessionState` к структуре `Session` (votes только внутри tasks) или
- Чётко задокументировать маппинг и добавить тесты конвертации

### 6. Race condition при одновременном голосовании

**Проблема:** Два участника голосуют почти одновременно:
1. Оба вызывают `get_session` → получают одну и ту же сессию
2. Оба модифицируют и вызывают `save_session`
3. Последний `save_session` перезаписывает первый

**Решение (низкий приоритет):**
- Оптимистичная блокировка (версия/updated_at)
- Или кратковременная блокировка на `(chat_id, topic_id)` при голосовании

---

## Инкапсуляция и архитектура

### 7. Логика перехода «следующая задача / завершить батч» в handler

**Проблема:** В `handle_vote` смешаны:
- бизнес-логика («все проголосовали» → перейти к следующей)
- работа с `current_task_index`
- вызов `_start_next_task` / `_finish_batch`

**Решение:**  
`AdvanceToNextTaskUseCase.execute(chat_id, topic_id) -> Tuple[bool, Optional[Task]]`  
Возвращает `(batch_finished, next_task)`. Handler решает, показывать следующую задачу или итоги.

### 8. Session без методов изменения

**Проблема:** `Session` — по сути dataclass, изменения делаются снаружи (handlers, use cases).

**Решение (опционально):**
- Добавить методы вроде `advance_task()`, `move_task_to_end(task)` и т.п.
- Хранить инварианты внутри домена

---

## Рекомендации по UX / Planning Poker

### 9. Отсутствие «одновременного раскрытия»

**Текущее поведение:** Голоса видны сразу после нажатия.

**Классика:** Сначала все выбирают, потом — одновременное раскрытие.

**Рекомендация:** Либо явно описать в README, что это «упрощённый асинхронный Planning Poker», либо добавить режим «скрытые голоса до раскрытия» (сложнее в UI).

### 10. Метод подсчёта SP (max vs консенсус)

**Текущее:** Берётся максимальная оценка.

**Рекомендация:** Закрепить в документации: «Используется максимальная оценка при отсутствии консенсуса. Кнопка „Нужен пересмотр“ позволяет вернуть задачу в обсуждение».

---

## Рекомендуемый порядок фиксов

| # | Задача | Приоритет | Сложность |
|---|--------|-----------|-----------|
| 1 | Исправить тесты (await, async) | **High** | Средняя |
| 2 | Защита от `current_task_index = -1` в needs_review | **High** | Низкая |
| 3 | Удаление старого сообщения при смене задачи в `_start_next_task` | **High** | Низкая |
| 4 | Вынести «переход к следующей задаче» в use case | **Medium** | Средняя |
| 5 | Вынести «нужен пересмотр» в use case | **Medium** | Средняя |
| 6 | Согласовать SessionState/Session и добавить тесты | **Medium** | Средняя |
| 7 | Обновить README (методология, max vs консенсус) | **Low** | Низкая |

---

## Быстрые победы (можно сделать сразу)

1. **Тесты** — добавить `await` и `pytest.mark.asyncio`.
2. **needs_review** — проверка `len(session.tasks_queue) == 0` после `pop` с вызовом `_finish_batch`.
3. **_start_next_task** — перед отправкой нового сообщения вызывать `delete_message` для `active_vote_message_id`, если `edit` не удался.
